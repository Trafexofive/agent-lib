# --- Orchestration Schema: MK1 (Draft 2) ---
version: MK1.2 # Incrementing version slightly . yeap!
name: "schema-building-workflow-mk1-draft2"
description: "Adds script/context imports, execution modifiers, explicit vars, IO mapping, and new variable syntax $(...)."

# --- Import Section ---
# Defines external resources to load/prepare before workflow execution.
# FUTURE: Define precise loading order and conflict resolution.
import:
  workflows:
    # - ./common_error_handler.yaml # FUTURE: Load entire workflows or sub-workflows to be called.
  agents:
    # Load agent profiles from YAML files. Agent's internal 'name' is the reference key.
    - ./agents/response_formatter.yaml
    # FUTURE: Implement loading all *.yaml from a directory. Agent names from files used as keys.
    - ./agents/data_validators/
  defines:
    # - ./standard_steps.yaml # FUTURE: Import definitions from shared files.
  scripts: # Load external scripts to be potentially used as tools or executed directly.
    # Load a single script file. Tool/reference name inferred from filename without extension ('aggregate-folder').
    - type: file
      path: ./scripts/standard/aggregate-folder.sh
      # runtime: bash # FUTURE: Could explicitly set runtime, otherwise infer from extension (.sh -> bash, .py -> python).
    # Load a single file and explicitly name the reference 'exp-tool'.
    - type: file
      path: ./scripts/standard/test.sh
      name: exp-tool # Overrides inferred name 'test'.
    # Load all scripts from a folder, creating a namespace 'boost'. Scripts accessed via 'boost.scriptName'.
    - type: folder
      path: ./scripts/boost-standard # Contains e.g., sendRequest.py, cleanup.sh
      name: boost # Namespace. Access via e.g., boost.sendRequest, boost.cleanup.
  context: # Prepare context variables/files available globally during workflow execution.
    # Load content of a file into a global context variable 'global.context.cpp-ref'.
    - type: file
      path: ./.resources/repo-cpp-code-refrences.md
      name: cpp-ref # Variable name. Access as $(global.context.cpp-ref).
      # var: global.code # FUTURE: Allow specifying the exact state variable path? Default to global.context.<name>.
    # Create/Prepare a context file on the filesystem before execution.
    - type: file
      path: ./.context # Path to the target file.
      create: true # Optional: Ensure file exists (create if not). Default: false? TBD.
      content: | # Optional: Set initial content (overwrites existing).
        # Initial context header
      append: # Optional: Append content from sources. Executes in order listed.
        - type: text # Append literal text.
          value: "\n--- Appended context ---\n"
        - type: file # Append content from another file.
          path: ./snippets/context_snippet.txt
        # - type: variable # FUTURE: Append content from a state variable?
        #   var: $(initial_state.query)
        - type: backup # Optional: Backup existing file before modifying.
          to: "./.context.backup_{timestamp}" # FUTURE: Add timestamp/pattern support.

# --- Initial State / Entrypoint ---
initial_state:
  query: "Find articles about AI in healthcare from the last month."
  search_result_count: 3
  user_id: "user123"
# entrypoint: step_id_start_here # FUTURE: Define a specific step ID to begin execution.

# --- Workflow Settings ---
settings:
  default_timeout: "60s"
  max_concurrent_steps: 1 # CURRENT: Sequential. FUTURE: > 1 enables parallelism.
  state_persistence: "none" # FUTURE: Configure state saving.
  error_handling_strategy: "fail_fast" # CURRENT: Stop on error. FUTURE: Add more strategies.
  # default_error_handler_step: ... # FUTURE
  debug_level: INFO

# --- Definitions ---
# Declare reusable components accessible by their keys (e.g., StandardSummarizer, BashExecutor).
defines:
  agents:
    StandardSummarizer:
      name: "StdSummarizer_Defined"
      system_prompt: "Provide a concise summary of the input text: $(input.text)" # Using new var syntax
      iteration_cap: 3
  tools:
    BashExecutor:
      name: "bash"
      description: "Executes a bash command provided as input."
      type: "script" # Renamed from "code" to "script" for clarity with imported scripts.
      runtime: "bash" # Explicit runtime.
      # reference: BashExecutor # FUTURE: Link to an imported script definition?
      code: | # Keep inline code option.
        #!/bin/bash
        echo "Executing command: $1" >&2
        eval "$1" # WARNING: Security risk!
  steps:
    LogStartStep:
      type: transform
      description: "Log the start of the workflow with the query."
      # Note: Using $(...) syntax for variable access. Requires parser update.
      expression: "'Workflow starting for query: ' + $(state.query)" # CURRENT: Basic concat. FUTURE: Needs robust expression engine.
      output: state.log.start_message

# --- Execution Rules ---
rules:
  execution_mode: "auto" # CURRENT: Start from first step. FUTURE: Add "explicit".
  sink: # Defines output destinations.
    - type: stdout # CURRENT: Print final result/logs.
    # FUTURE: Add stderr, file, http, client types.
  run: # detach | default | debug

# --- Main Workflow Steps ---
workflow:
  # Using a defined step.
  - id: start_logging
    ref: LogStartStep # References 'LogStartStep' from 'defines.steps'.

  # Step to explicitly set/modify a state variable.
  - id: set_global_query_var
    type: var # New step type for direct variable manipulation.
    description: "Store the initial query in a global variable for later reference."
    # Option A: Simple key-value assignment
    set:
      global.query_snapshot: $(state.query) # Assign value of state.query to global.query_snapshot
      global.timestamp: $(func.timestamp()) # FUTURE: Allow calling built-in functions?
    # Option B: More structured assignment (TBD which is better)
    # assignments:
    #   - target: global.query_snapshot
    #     value: $(state.query)

  - id: execute_search_query
    type: agent
    description: "Execute a refined web search using an inline agent and tools."
    # exec: # FUTURE: Override execution mode for this step.
      # mode: parallel # e.g., run multiple instances with different inputs.
      # count: 3
      # mode: schedule # e.g., run at a specific time or interval.
      # cron: "0 * * * *"
      # mode: loop # e.g., loop until condition met.
      # condition: ...
    timeout: "90s"
    depends_on: # FUTURE: Requires DAG execution support.
      - start_logging
    agent:
      define:
        name: "WebSearcher_Inline"
        system_prompt: |
          You are a web search assistant. Execute the search query precisely.
          Query: $(input.search_query)
          Max Results: $(input.max_results)
          Return URLs and snippets. Use available tools if needed.
        iteration_cap: 5
        tools:
          define: # Define tools inline for this agent instance only.
            - name: "URLValidator"
              description: "Checks if a URL is reachable."
              type: "script" # Tool implemented via code/script.
              runtime: "python"
              # parameters: { url: string } # FUTURE
              code: | # Inline code.
                import requests
                # ... (code as before) ...
                def run(params): return {"valid": validate(params.get('url', ''))}
          internal: # Reference tools defined globally (in 'defines' or imported).
            - "bash" # Tool named 'bash', likely references BashExecutor.
          # external: # FUTURE: Reference external APIs/services.
          #   - ...

    # Using separate input/output fields:
    input:
      search_query: "$(state.query)" # Using $(...) syntax for variable access.
      max_results: "$(state.search_result_count)"
    output: state.search_results # Where to store the agent's final output.

  - id: summarize_results
    type: agent
    description: "Summarize the search results using a defined agent."
    agent:
      ref: StandardSummarizer # Reference agent defined in 'defines.agents'.
    # Using the alternative IO mapping field:
    IO:
      # Maps the content of state variable 'state.search_results' to the 'input.text' expected by the agent's prompt.
      "$(state.search_results)": input.text
      # Maps the agent's final output (implicitly 'agent.output') to the state variable 'state.summary'.
      agent.output: state.summary
    # Note: The 'IO' field aims to replace 'input'/'output' for certain mapping scenarios.
    # Its exact semantics (especially agent.output implicit variable) need careful design.
    # TBD: How does IO interact with complex inputs/outputs or multiple mappings? Sticking with input/output might be clearer.

  - id: present_results
    type: transform
    description: "Format final results combining search and summary."
    depends_on: # FUTURE
      - execute_search_query
      - summarize_results
    # Using $(...) syntax in expression.
    expression: "'Summary based on search for query [' + $(global.query_snapshot) + ']:\\n' + $(state.summary)"
    output: final_output # Special target indicating the workflow's final result.
