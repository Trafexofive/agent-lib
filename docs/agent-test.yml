# --- Orchestration Schema: MK1 ---
version: MK1
name: "schema-building-workflow"
description: "Workflow demonstrating imports, definitions, settings, and inline agent/tool configurations. Pre/post steps removed for this draft."

import:
  # --- Import Section ---
  # Allows including external resources. Execution order/priority TBD.
  workflows:
    # - ./common_error_handler.yaml # FUTURE: Load entire workflows
  agents:
    # Load agent profiles from YAML files or directories
    - ./agents/response_formatter.yaml # Load a specific agent profile
    - ./agents/data_validators/ # FUTURE: Load all *.yaml from a directory?
    # - name: explicit_formatter (will be inferend from parased and loaded agent file.) or just simply ovveride the name
    #   path: ./agents/response_formatter.yaml
  defines:
    # - ./standard_steps.yaml # FUTURE: Import definitions from other files
  # tools: # FUTURE: Import tool definitions?
    # - ./common_tools.yaml

# --- Initial State or Entrypoint ---
# Option A: Define initial variables
initial_state:
  query: "Find articles about AI in healthcare from the last month."
  search_result_count: 3
  user_id: "user123"

# Option B: Define an entrypoint step (could override initial_state or work with it)
# entrypoint: step_id_start_here # ID of the first step to execute

# --- Workflow Settings ---
settings:
  # General settings affecting workflow execution
  default_timeout: "60s" # Default timeout for steps unless overridden
  max_concurrent_steps: 5 # Limit for parallel execution (FUTURE)
  state_persistence: "none" # "none", "local_file", "database" (FUTURE)
  error_handling_strategy: "fail_fast" # "fail_fast", "continue", "jump_to_error_handler" (FUTURE)
  # default_error_handler_step: "global_error_handler" # FUTURE: ID of a step to jump to on unhandled errors
  debug_level: INFO

# --- Definitions ---
# Define reusable components (agents, tools, steps) without executing them immediately.
# These can be referenced later in the main workflow.
defines:
  agents:
    StandardSummarizer: # Reusable agent definition by name
      name: "StdSummarizer_Defined"
      system_prompt: "Provide a concise summary of the input text."
      iteration_cap: 3
      # tools: ... # Can include tools here too
  tools:
    BashExecutor: # Reusable tool definition
      name: "bash"
      description: "Executes a bash command."
      type: "code" # Indicate it's code-based
      runtime: "bash" # Specify runtime
      code: |
        #!/bin/bash
        eval "$1" # Example: takes command as first arg (Needs refinement for safety!)
      # parameters: ... # Define expected input parameters
  steps:
    LogStartStep: # Reusable step definition
      id: LogStartStep # Note: ID here is for reference within defines, might be different when used
      type: transform # Example: could be logging, data validation etc.
      description: "Log the start of the workflow with the query."
      expression: "'Workflow starting for query: ' + {state.query}"
      output: state.log.start_message # Example: Log to a specific part of the state
    # ... other reusable steps

# --- Execution Rules ---
rules:
  execution_mode: "explicit" # "auto" (start from first step), "explicit" (requires entrypoint or external trigger)
  sink: # stdout, stderr, curl(could be sending to an API), client (I mainly want to have a term window running  live client that can received from agents and workflows, a pannel where agents stream their output basically.
  # FUTURE: Could add rules for depends_on only, parallel steps state access, retries, etc.

# --- Main Workflow Steps ---
workflow:
  # Example using a defined step
  - ref: LogStartStep # Reference a step defined in the 'defines' section
    id: start_logging # Give it a unique ID for this specific use in the workflow

  - id: execute_search_query
    type: agent # Specify the step type
    description: "Execute a refined web search using an inline agent and tools."
    timeout: "90s" # Override default timeout
    depends_on: # FUTURE: Define dependencies (step IDs) for DAG execution
      - start_logging # This step won't start until 'start_logging' completes
    agent: # Structured agent key
      define: # Defining the agent inline for this step
        name: "WebSearcher_Inline"
        system_prompt: |
          You are a web search assistant. Execute the search query precisely.
          Query: {input.search_query}
          Max Results: {input.max_results}
          Return URLs and snippets. Use available tools if needed.
        tools: # Define tools available ONLY to this inline agent
          define: # Define a tool inline ONLY for this agent
            - name: "URLValidator"
              description: "Checks if a URL is reachable."
              type: "code" # Example: Could be code or reference an external API/service
              runtime: "python" # Specify runtime
              parameters:
                url: "string"
              code: | # Example inline python code
                import requests
                def validate(url):
                  try:
                    response = requests.head(url, timeout=5)
                    return response.status_code < 400
                  except requests.RequestException:
                    return False
                # Entry point assumption: execute function named 'run' or 'execute'
                def run(params):
                  is_valid = validate(params.get('url', ''))
                  return {"valid": is_valid}
          internal: # List internal tools the agent might be aware of (if registered globally/via import)
            - "bash" # Assumes a 'bash' tool is available (e.g., from defines)
          external: # List external tools/APIs (more conceptual unless specific integration exists)
            - "google_search_api" # Agent might know how to format calls for this

    input: # Define input for this step (potentially using state from previous steps)
      search_query: "{state.query}" # Using initial state directly for this example
      max_results: "{state.search_result_count}"
    output: state.search_results # Output from this agent step

  - id: summarize_results
    type: agent
    description: "Summarize the search results using a defined agent."
    agent:
      ref: StandardSummarizer # Reference an agent defined in the 'defines' section
    input: "{state.search_results}"
    output: state.summary

  - id: present_results
    type: transform # Example: a step that formats output without an LLM agent
    description: "Format final results combining search and summary."
    depends_on:
      - execute_search_query
      - summarize_results
    expression: "'Found Results (' + len({state.search_results}) + '):\\n' + {state.summary}" # Example expression (needs evaluator)
    output: final_output # Special key indicating the final result of the workflow
